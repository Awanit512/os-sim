<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CPU Scheduling</title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="" name="keywords">
  <meta content="" name="description">

  <!-- Favicons -->
  <!--<link href="img/favicon.png" rel="icon">-->
  <!--<link href="img/apple-touch-icon.png" rel="apple-touch-icon">-->

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,700,700i|Poppins:300,400,500,700" rel="stylesheet">

  <!-- Bootstrap CSS File -->
  <link href="../lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Libraries CSS Files -->
  <link href="../lib/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link href="../lib/animate/animate.min.css" rel="stylesheet">

  <!-- Main Stylesheet File -->
  <link href="../stylesheets/wiki.css" rel="stylesheet">

  <style>
      #about .about-container .background {
          min-height: 300px;
          background: url(../images/PC1.png) center top no-repeat;
          margin-bottom: 10px;
      }
  </style>
</head>

<body>

  <!--==========================
  Header
  ============================-->
  <header id="header">
    <div class="container">

      <nav id="nav-menu-container">
        <ul class="nav-menu">
          <li><a href="#about">Wiki</a></li>
          <li><a href="#services">Simulate</a></li>
        </ul>
      </nav><!-- #nav-menu-container -->
    </div>
  </header><!-- #header -->

  <!--==========================
    Hero Section
  ============================-->
  <section id="hero">
    <div class="hero-container">
      <h1>CPU Scheduling algorithms</h1>
      <h2>As we know that on a single Computer we can Perform Many Operations at a Time so that Management is also necessary on all the Running Processes those are running on the System at a Time. With the help or Advent of the Multi-programming we can Execute Many Programs at a Time. So fir Controlling and providing the Memory to all the Processes Operating System uses the Concept of Disk Scheduling.</h2>
      <a href="#about" class="btn-get-started">Learn more</a>
    </div>
  </section><!-- #hero -->

  <main id="main">

    <!--==========================
      About Us Section
    ============================-->
    <section id="about">
      <div class="container">
        <div class="row about-container">

          <div class="col-lg-6 content order-lg-1 order-2">
            <h2 class="title">Wiki about CPU scheduling</h2>
            <p>
              Disk scheduling is is done by operating systems to schedule I/O requests arriving for disk. Disk scheduling is also known as I/O scheduling.
            </p>

            <div class="icon-box wow fadeInUp">
              <div class="icon"><i class="fa fa-shopping-bag"></i></div>
              <h4 class="title"><a href="">First Come First Serve Scheduling</a></h4>
              <p class="description">In the First Come First Serve scheduling algorithm the process which arrives first, gets executed first, or the process which requests the CPU first, gets the CPU allocated first. Next process starts only after the previous gets fully executed. The implementation of the FCFS policy is easily managed with a FIFO queue. FCFS scheduling algorithm is simple and easy. However it is non preemptive and the process will run to completion. Although it is easy to implement, but it is poor in performance since the average waiting time is higher as compare to other scheduling algorithms.</p>
            </div>

            <div class="icon-box wow fadeInUp" data-wow-delay="0.2s">
              <div class="icon"><i class="fa fa-photo"></i></div>
              <h4 class="title"><a href="">Shortest Job First Scheduling</a></h4>
              <p class="description">The idea behind the SJF algorithm is to pick the shortest job in the ready queue that needs to be done and then pick the next smallest fastest job to do next. If the next CPU bursts of two processes are the same, FCFS scheduling is used to break the tie. The SJF scheduling algorithm is provably optimal, in that it gives the minimum average waiting time for a given set of processes. Moving a short proess before a long process decreases the waiting time of the short process more than it increasese the waiting time of the long process. The real difficulty with the SJF algorithm is knowing the length of the next CPU request.</p>
            </div>

            <div class="icon-box wow fadeInUp" data-wow-delay="0.4s">
              <div class="icon"><i class="fa fa-bar-chart"></i></div>
              <h4 class="title"><a href="">Shortest Remaining Time First Scheduling</a></h4>
              <p class="description">Shortest remaining time, also known as shortest remaining time first (SRTF), is a scheduling method that is a preemptive version of shortest job next scheduling. In this scheduling algorithm, the process with the smallest amount of time remaining until completion is selected to execute. Since the currently executing process is the one with the shortest amount of time remaining by definition, and since that time should only reduce as execution progresses, processes will always run until they complete or a new process is added that requires a smaller amount of time.
</p>
            </div>

<div class="icon-box wow fadeInUp" data-wow-delay="0.4s">
              <div class="icon"><i class="fa fa-bar-chart"></i></div>
              <h4 class="title"><a href="">Round Robin Scheduling</a></h4>
              <p class="description">To schedule processes fairly, a round-robin scheduler generally employs time-sharing, giving each job a time slot or quantum[4] (its allowance of CPU time), and interrupting the job if it is not completed by then. The job is resumed next time a time slot is assigned to that process. If the process terminates or changes its state to waiting during its attributed time quantum, the scheduler selects the first process in the ready queue to execute. Round-robin algorithm is a pre-emptive algorithm as the scheduler forces the process out of the CPU once the time quota expires.</p>
            </div>


<div class="icon-box wow fadeInUp" data-wow-delay="0.4s">
              <div class="icon"><i class="fa fa-bar-chart"></i></div>
              <h4 class="title"><a href="">Preemptive Priority Scheduling</a></h4>
              <p class="description">In Preemptive Priority Scheduling, at the time of arrival of a process in the ready queue, its Priority is compared with the priority of the other processes present in the ready queue as well as with the one which is being executed by the CPU at that point of time. The one with the highest priority among all the available processes will be given the CPU next. If a new process having a higher priority than the currently running process arrives, it gets selected immediately. The new process has not to wait until the currently running process finishes or yields.
</p>
            </div>


<div class="icon-box wow fadeInUp" data-wow-delay="0.4s">
              <div class="icon"><i class="fa fa-bar-chart"></i></div>
              <h4 class="title"><a href="">Priority Ageing scheduling</a></h4>
              <p class="description">Ageing is a scheduling technique used to avoid starvation. Fixed priority scheduling is a scheduling discipline, in which tasks queued for utilizing a system resource are assigned a priority each. A task with a high priority is allowed to access a specific system resource before a task with a lower priority is allowed to do the same. A disadvantage of this approach is that tasks assigned with a lower priority may be starved when a large number of high priority tasks are queued. Aging is used to gradually increase the priority of a task, based on its waiting time in the ready queue.
</p>
            </div>

<div class="icon-box wow fadeInUp" data-wow-delay="0.4s">
              <div class="icon"><i class="fa fa-bar-chart"></i></div>
              <h4 class="title"><a href="">Multilevel Queue Scheduling</a></h4>
              <p class="description">In Multilevel Queue Scheduling algorithm the ready queue is divided into separate queues. Based on some priority of the process, like memory size, process priority, or process type these processes are permanently assigned to one queue. Each queue has its own scheduling algorithm. There will be scheduling between the queues which are easily implemented as a fixed- priority preemptive scheduling.
</p>
            </div>

          </div>

          <div class="col-lg-6 background order-lg-2 order-1 wow fadeInRight"></div>
        </div>

      </div>
    </section><!-- #about -->


    <section id="services">
      <a href="/cpu_scheduling" class="btn-get-started" style="position: absolute; left:44%;">Run Simulation</a>
    </section>

  </main>

  <a href="#" class="back-to-top"><i class="fa fa-chevron-up"></i></a>

  <!-- JavaScript Libraries -->
  <script src="../lib/jquery/jquery.min.js"></script>
  <script src="../lib/jquery/jquery-migrate.min.js"></script>
  <script src="../lib/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="../lib/easing/easing.min.js"></script>
  <script src="../lib/wow/wow.min.js"></script>
  <script src="../lib/waypoints/waypoints.min.js"></script>
  <script src="../lib/counterup/counterup.min.js"></script>
  <script src="../lib/superfish/hoverIntent.js"></script>
  <script src="../lib/superfish/superfish.min.js"></script>

  <!-- Template Main Javascript File -->
  <script src="../javascripts/wiki.js"></script>

</body>
</html>
